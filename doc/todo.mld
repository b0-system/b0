{0:design_todo Design considerations and todo}


{1:b0_std [b0.std] library}

{ul
{- Review the tool lookup stuff. First we may want to
   generalize the lookup path to a function (rather than list of paths).
   Then maybe we should simply have a DLS global.}}

{1:design_b0 [b0.memo] library}

- The signature of {!B0_memo.write} looks wrong you want a fut. E.g.
  we don't want to the [Fut.sync] here.

  {[
let crunch_file m file ~in_dir =
  let open Fut.Syntax in
  let mn = B0_ocaml.Mod.Name.of_mangled_filename (Fpath.basename file) in
  let out = Fpath.(in_dir / String.Ascii.uncapitalize mn + ".ml") in
  B0_memo.Memo.write m out ~reads:[file] begin fun () ->
  (* FIXME b0 the sig of write is wrong *)
  let data = Fut.sync (B0_memo.Memo.read m file) in
  Ok (B0_memo_ocaml.Crunch.string_to_string ~id:"file" ~data)
  end;
  Fut.return out

]}

{1:design_b0_file [b0.file] library}

{ul
{- [B0.ml] file finding. Should we stop at the last B0.ml file upwards ?
   This would be nice if you operate in a vendored dir. But this also
   avoid problems like I do a checkout e.g. in a scratch directory in
   [_b0] to build it. On the other hand we have [--b0-file] for these cases.}
{- Should a [@@@B0.version] be added ? Think harder about
   it an especially with respect to [B0_kit.V000] versioning. and
   coherence with [@@@B0.include]s. Also we could require to specify
   say [#require "b0.kit.v000"]. Write down a few properties
   we would like to have w.r.t. opam and/or inclusion and end-user
   support. If we use [@@@B0.version] rather than open we might get
   in trouble with merlin. }
{- Scope name for libraries the [lib] think may not be that
   good and rather confusing. Maybe devise a specific notation
   to access library definitions and allow dots in their name.
   (["/my.def.bla"])}}

{2:fragments Build fragments}

At the B0 level we need to expose build fragments. It seems the build
procedures of units is a good candidate but for now it's a bit unconvient
to do that. We need to clarify the configuration store and dynamic
metadata see {!b0_meta}.

For now as a temporary hack we add the [wrap] parameter to units.

{2:b0_env [B0_env]}

- Maybe we should start exposing a mini [Os] in [B0_env] for
  actions. This might be needed for remote builds. In fact
  at some point we should indicate on which Os the action
  happens [`Build], [`Host] or [`Driver] (b0 invocation).
  Not sure we need the last one. Maybe it's then sufficient
  to a proxy dance by executing the same b0 driver executable
  on the remote platform, at which point the [Os] invocation
  run on the right platform. Do we ever want mixed [`Build] and
  [`Host] ? Not undoable but a bit cold feet on replacating all
  the `Os` module.

{2:b0_action [B0_action]}

- Maybe we could specify an option that an action always requires a
  build and defaults to the default build if none is explicitely
  specified. This could be useful or not for [.ocaml ocaml]. Though
  you likely often only want to test an excutable so it's just a [b0
  -u myexec -- .ocaml ocaml].

- Store keys on the build of an action, that works but it means we
  can't do that on specific subcommands when the action is a cmdliner
  group cmd. E.g. it would be nice to have everything for `ocaml`
  under `.ocaml` but `.ocaml ocaml` or `.ocaml utop` will want a byte
  code build and `.ocaml ocamlnat` will want a native code build. So
  for now we have `.ocaml.ocaml`

- Access control. Maybe actions accessing the full builds opens a can
  of worms (or not) we could try to enforce more access control via
  the definition scope of the action (lib vs. file).

- Execution logic. Unit name and action name conflicting should be
  resolved locally. If a tool conflicts with action warn but use tool,
  [b0 action exec] can be used for the action. If a tool conflicts
  with a unit warn if it's not the same unit. We should again add a
  [b0 unit exec], we should also maybe add a [b0 tool] command.

- The current scheme is not yet what we want.  One reason is that it's
  not a good idea to first build and then parse the cli args, we
  should error asap. The second one is that we really want some
  actions to be able to define what to build dynamically. This is
  unconvenient to do right now.


{2:b0_unit [B0_unit]}

For now we used ['a Fut B0_meta.key].
{ul
{- See how it goes fares for sync. Push/pull.}
{- What about serializing them so that it can be read
   by `b0 unit get` ?}
{- Why do unit exec not use {!B0_env} ? There is logic
   we want to reuse there, e.g. lookup for tools in the build.}}

{2:b0_meta [B0_meta]}

- They used to be serializable, see if we don't want that again. Especially
  in the optic of a merge with B0_store.
- I think keys should be scoped or B0_defs (but that depends on B0_meta)
- In the context of a merge with [B0_store] it should be possible
  to determine keys in various ways without needing to be explicit
  about it like the datatype of {!B0_unit.val-exec_env} is.

{2:b0_store [B0_store]}

It's a bit unclear whether we don't want to merge [B0_meta]
and [B0_store] perhaps at the expense of more complex
[B0_meta.Key].

Also for now only actions can mandate store bindings (e.g. to request
a bytecode build). This should of course be user definable, likely at
the build variant level.

{2:b0_ocaml [B0_ocaml]}

- We should let constraints be defined on libraries. Then we can
  auto-generate opam constraints.
- Implement the [public] visibility stuff in the library resolver.

{1:b0_kit [b0.kit] library}

{2:b0_opam [B0_opam]}

- Worfklow to easily check opam file in sync. Part of more general
  workflow ? In fact it would be better to have
 {:https://github.com/ocaml/opam/issues/3797}

{2:b0_expect [B0_expect]}

- Default cli driver, integrate with the plans on general actions.
- Parallel execution
- Progress
- VCS agnostic, i.e. fill-in the hg support
- Have test for a full program execution effect (file system, exit
  code, standard outputs) via a dedicated machine readable file that
  is updated by the run.
- Get a story for binary/visual regression. First we should have a
  good `git difftool` and `pixeldrift` setup regardless of
  testing. Then we likely want combinators that automatically checkout
  the rewritten path if the perception threshold is not
  trigerred. Basically in case we detect a modified `path`, invoke a
  perceptual tool with `path` and `git show HEAD:path`, if the tool
  exits with 0 do a `git checkout path` to make it as if nothing
  happened.
- Add a notion of group in Outcome.test.
- Add filtering to selectively test expecations. Based on group names
  and file globs.
- Logging maybe move to:
  {ul
  {- normal, paths but no diff}
  {- long, paths and diffs}
  {- short, only final summary}}
- Add a small manual to the action.

{2:b0_show_url [B0_show_url]}

{ul
{- For now only toolname defined in units (as defined by [b0 tool list]) can
   be used for the URL/tool execution form.

   We likely want to be able to use it with actions aswell. But this
   needs a bit of twisting around since currently the action bit gets
   invoked at the end of the build. We need to be able to influence
   the build itself (especially since actions can influence the store)
   and for example the pack and units requires need to be able to be
   defined dynamically.

   Basically currently it's difficult for actions to invoke actions.}}

{1:doc Documentation overhaul}

- Howto on action/unit execution

- B0.ml file style guide. Toplevel defs, constructor at the
  end except for actions. doc strings either inline or first thing
  after defining [let].

- Metadata convention. While it may entail user errors if certain
  meta is needed by build unit. It's better that the optional
  `meta` always provides a final override over any key.
