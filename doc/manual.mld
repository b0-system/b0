{0 B0 manual}

This manual provides a conceptual overview of the B0 system and
explains the mechanics of B0 files. Other manuals are described and
available {{!page-index.manuals}here}.

{1:intro Introduction}

B0 seeks at liberating the programmer from the tedious but essential
bureaucratic tasks that {e surround} the programming activity. It
provides a shell in which software construction and deployment
problems can be solved, reused and customized, using a decent
description language.

B0 describes:

{ul
{- The build environment.}
{- The software configuration, build and testing.}
{- Source or binary artefact deployments.}
{- Custom workflow actions.}}

These descriptions are made in a {e B0 file} which we describe
next.

{1:b0_file The B0 file}

The B0 file is a syntactically valid OCaml file possibly prefixed by a
few {{!directives}directives}. The OCaml code creates definitions to
describe the software by using the versioned {!B0_file} API and
possibly other third-party OCaml {{!libs}libraries}.

The B0 file is named [B0.ml]. It is usually located at the root of a
project's source tree and centralizes the definitions that describe
the software.

{2:drivers B0 file drivers}

The B0 file definitions are consulted and executed by {e drivers}. The
[b0] and [d0] tools distributed with B0 are examples of drivers. An
API is provided to create custom driver, see the {{!page-b0_driver_dev}
B0 driver development manual}.

{2:root_b0_file Root B0 file}

The B0 file executed by a driver is called the {e root B0 file}. When
a driver like [b0] is invoked in a directory [cwd], the root B0 file
is the {e first} [B0.ml] file found starting at the [cwd] and moving
upwards in parent directories.

The root B0 file can also be specified explicitely via the [--b0-file]
option or the [B0_FILE] environment variable. Invoke [b0 file path] to
find out which root B0 file is determined by [b0].

{2:root_dir Root and [_b0] directory}

The {e root directory} is the directory in which the
{{!root_b0_file}root B0 file} is found. Most of the time the root
directory coincides with the root of the project's source
tree. However in case a root B0 file simply gathers multiple project
definitions by {{!inclusion}including} B0 files the root directory may
be empty.

The root directory is where the scratch {e [_b0] directory} used by
drivers to operate and store their results gets created by
default. The location of the [_b0] directory can also be specified
explicitely via the [--b0-dir] option or the [B0_DIR] environment
variable. [_b0] directories should be ignored by version control
systems.

{2:rel_paths Relative file paths}

Unless otherwise indicated relative file paths specified in
definitions and directives of a B0 file are {e always} relative to
the directory where the B0 file lies.

{2:inclusion Including B0 files}

The {{!directive_include}[@@@B0.include]} directive provides a
mecanism to compose B0 files. The intent of B0 file inclusion is to be
able to aggregate independent software (sub)projects or to vendor
dependencies. Include directives must be specified {e at the
start} of a B0 file, before any comment or OCaml code.

For example the following [B0.ml] file includes the definitions of two
other B0 files:

{[
[@@@B0.include "../that-lib/B0.ml"]
[@@@B0.include "projects/proj/B0.ml"]
]}

{3:scope Scopes}

An included B0 file defines a named {e scope} [s] to which its
definitions are added. From the B0 file that includes, the syntax to
access a definition named [d] in a scope [s] is [s.d].

By default the name of the scope is automatically derived from the
directory name of the B0 file. In the example above the scope names
are, in order, [that-lib] and [proj].

The scope name can also be explicitely specified on inclusion. For example in:

{[
[@@@B0.include "that" "../that-lib/B0.ml"]
[@@@B0.include "projects/proj/B0.ml"]
]}

the scope name of the file ["../that-lib/B0.ml"] is [that] rather than
[that-lib].

Scope names must be unique in a given B0 file and must not contain
['.']  characters. The [lib] scope name is reserved and can't be
used. It is used as a root scope for library definitions. If these
constraints are not satisfied the B0 file errors.

{3:access Access control and isolation}

At definition time a B0 file can only access definitions that are in
its own scope or in the scope of the files it [@B00.include]s and
recursively. This means that in any B0 file:

{[
let all_units = B0_unit.list () (* get all units defined so far *)
]}

the value [all_units] depends only on the definitions and includes of
the B0 file itself, however included it may be itself.

In the example above the two included B0 files cannot refer to the
names of the other directly at definition time. However at build time
their definitions may interact indirectly via metadata and build logic
name resolution procedures which have access to the global scope, see
{!vendoring}.

The {e OCaml language} scope of included files is not accessible and fully
isolated. Both includer and includee cannot access each other's
OCaml identifiers.

{3:vendoring Dependency vendoring}

Support for build dependency vendoring depends on the name resolution
procedure of the build logic you are using.

If the build logic you use is able to look in the definitions of the
root B0 file for dependencies and use these instead of those found in the
build environment then vendoring is simply a matter of
[@@@B0.includ]ing the definitions of the dependencies to your B0 file.

A typical setup is to have at the root of a project:

{v
B0.ml
vendor/dep1/
vendor/dep2/
src/
v}

and to start your project's [B0.ml] file with:

{[
[@@@B0.include "vendor/dep1/B0.ml"]
[@@@B0.include "vendor/dep2/B0.ml"]
...
]}

Since dependencies may have vendored dependencies themselves,
coherence issues may arise. You may have to define new consistent and
locked {{!packs}build packs} in the root B0 file in order to exclude
conflicting dependencies.

{2:libs Using libraries}

B0 is a modular and extensible system. It is {e expected} for
third-parties to define abstractions and build logics and distribute
them as libraries.

Any OCaml library available in the [OCAMLPATH] can be used in a B0
file by requiring it via the {{!directive_require}#require}
directive. [#require] directives must be specified {e at the very
start} of the file, before any comment or OCaml code.

For example:

{[
#require "mylib"
]}

instructs to lookup library [mylib] in the [OCAMLPATH] and use
it to compile the B0 file.

{2:boot B0 file bootstrap}

A B0 file is an OCaml source and may need {{!libs}additional} OCaml
libraries. This means it needs an OCaml compiler in the user [PATH]
and the [#require]d libraries in the [OCAMLPATH].

Making sure these libraries are available is the purpose of B0 file
boostrapping. The {{!directive_boot}[@@@B0.boot]} directive allows to
specify a system to run in order to install the B0 file prerequistes.

For example the following directive:

{[
[@@@B0.boot "opam" "my-logic>=1.0.0"]
]}

indicates the B0 file needs the [my-logic] package to be installed
with version greater or equal than 1.0.0. The syntax for opam package
names and constraints follows that of the [opam install] command.

This declaration allows to install the B0 file prerequisites by invoking:

{[
b0 file boot --opam
]}

{1:definitions B0 file definitions}

This section provides a high-level view of the definitions made in B0
files to describe the software.

B0 definitions are named and {e static}. The latter means they need to
be defined during the initialisation of the B0 file. This allows
end-user to act and query them from user interfaces.

{2:meta Metadata}

All definitions in B0 have a metadata dictionary of type {!B0_meta.t}
attached. Metadata is used to drive build logics and inform custom
actions and deployments.

The type {!B0_meta.t} is a simple type-safe heterogenous value map. A
few {{!B0_meta.standard_keys}standard keys} are provided, consider
using these before defining your own. Also consult libraries of build
logic which may define more.

{2:units Build units}

A build unit gathers sets of related low-level build operations
(e.g. tool spawns). Typical build units are sequences of commands that
build a library, an executable, etc.

Build units structure builds in well identified fragments, they form
the smallest unit of build that can be be requested from the command
line.

They are given a build directory in [_b0] according to the build
environment and their name where they {e should}, but are not required
to output their results.

{2:packs Build packs}

A build pack gathers a set of {{!units}build units}. Build packs have
no formal operational functionality in the system. It is just a way to
list build units under a name and perform coarse grained actions on
them. Note that a build unit can belong to more than one pack.

Here are example of pack usage in the system:

{ul
{- Define convenience subsets, possibly locked, of units to build.
   These builds can then be easily triggered via the [-p] option
   of [b0 build].}
{- Define metadata and build units to create a distribution package. For
   example opam package descriptions can be generated from build packs.}
{- Define build prerequisites for actions and deployments}}

{3:default_pack The [default] pack}

The [default] pack defines the build units that are built when a bare
[b0 build] is invoked.

{2:variants Build variants}

{3:default_variant The [default] variant}

{3:user_variant The [user] variant scheme}

{2:actions Actions}

{1:b0_file_reference B0 file reference}

The following parts can be distinguished in a B0 file:

{ol
{- The initial sequence of {{!directives}directives}. Before any comment
   or OCaml construct.}
{- The OCaml unit implementation.}}

The order is important. Directives that are mentioned after the OCaml
unit implementation starts are either silently ignored ([@@@B0.*]
directives) or produce compilation errors ([#*] directives).

{2:b0_file_syntax Syntax}

A B0 file is white space (no comments) separated directives followed
by an
{{:http://caml.inria.fr/pub/docs/manual-ocaml-4.09/compunit.html#unit-implementation}OCaml
unit implementation}.

Using an {{:https://tools.ietf.org/html/rfc5234}RFC 5234} grammar this
reads as:

{v
b0_file    = *(ws directive) ws unit-implementation
directive  = dir-boot / dir-inc / dir-req
dir-boot   = "[@@@B0.boot" *(ws dstring) ws "]"
dir-inc    = "[@@@B0.include" *(ws dstring) ws "]"
dir-req    = "#require" ws dstring
dstring    = %x22 dchar *dchar %x22
dchar      = escape / cont / ws / %x21 / %x23-%x5B / %x5D-%x7E / %x80-xFF
escape     = %x5C (%x20 / %x22 / %x5C)
cont       = %x5C nl ws
ws         = *(%x20 / %x09 / %x0A / %x0B / %x0C / %x0D)
nl         = %x0A / %x0D / %x0D %x0A
unit-implementation = ... ; See the syntax in the OCaml manual
v}

{2:directives Directives}

{3:directive_boot Directive [@@@B0.boot]}

The syntax of the [@@@B0.boot] directive is:

{[
[@@@B0.boot "SYSTEM" "ARG"... ]
]}

At the moment the only known value for ["SYSTEM"] is ["opam"] and its
argument names are packages constraints using the same syntax as the
[opam install] command:

{[
[@@@B0.boot "opam" "PKG"... ]
]}

This indicates the [opam] package [PKG] need to be installed in order
to compile the B0 file.

{3:directive_include Directive [@@@B0.include]}

The syntax of the [@@@B0.include] directive is one of:

{[
[@@@B0.include "PATH"]
[@@@B0.include "NAME" "PATH"]
]}

The semantics is to include in the B0 file the definitions of
the B0 file at ["PATH"] in a scope named ["NAME"]. If ["NAME"] is
is not specified the directory name of the included B0 file is used.

["NAME"] must be unique among the B0 files included in the file and must
not contain ['.'] characters.

{3:directive_require Directive [#require]}

The syntax of the [#require] directive is:

{[
#require "LIB"
]}

The semantics is to compile and link the B0 file against library
[LIB], looked up in the [OCAMLPATH]. At the moment library [LIB]'s
dependencies must be manually [#required] aswell.

{1:design_todo Design considerations and todo}

{2:design_b0_file B0 file}

{ul
{- [B0.ml] file finding. Should we stop at the last B0.ml file upwards ?
   This would be nice if you operate in a vendored dir. But this also
   avoid problems like I do a checkout e.g. in a scratch directory in
   [_b0] to build it. On the other hand we have [--b0-file] for these cases.}
{- Should a [@@@B0.version] be added ? Think harder about
   it an especially with respect to [B0_file.V000] versioning. and
   coherence with [@@@B0.include]s. Also we could require to specify
   say [#require "b0.care.v000"]}}

{2:design_b0_tool [b0] tool}

{ul
{- What to build by default, on [b0 build] ?
   {ul
   {- Define explicitely a [default] pack. Good explicit and easy to
      track on the cli. Bad, a bit annoying when starting a project, don't
      make me type, also when I define a new unit I'll likely forget about
      putting it in the default.}
   {- Define an [implied] tag on units (default true) and pack (default false)
      only implied units/packs defined in the B0 file root get built.}
   {- Maybe something more fine grained based on tags would e.g. exclude
      tests. See if we introduce artefact tags like [test, doc, exe, lib]
      etc.}}}}
