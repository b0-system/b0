{0 Testing with [b0 test]}

The [b0] tool provides a simple test runner via the [b0 test] command.

The principle of this command is simple, it makes a build like a [b0]
or [b0 build] invocation does and any unit that {e must} build and
that is tagged with {!B0_meta.test} and {!B0_meta.run}, is executed
once built. Units that sport these two tags can be spotted by a green
T in [b0 list].

So doing a:

{@sh[
b0 test
]}

Builds the default pack and excutes the runnable tests therein. If any
test exits with a non-zero error code, the build fails the test and
the invocation exits with [1]. If a test executable runs multiple
tests it is advised to report the number of failing tests as the exit
code.

The granularity of tests is the executable unit. But you can easily
devise your own test subsets via packs and the usual build selection
options [-u], [-p], [-x] and [-X]. For example:

{@sh[
b0 test -p special_tests -x that_long_test
]}

The [--what] option tells you which tests will effectively be run
and what will build (like [b0 --what] does).

{@sh[
b0 test -p special_tests -x that_long_test --what
]}

{1:long_tests Long tests}

TODO add [B0_meta.long] and only invoke these test when
[b0 test --long] is provided.

{1:testing_ocaml_code Testing OCaml code}

The infrastructure described above allows to hook the testing
framework of your wish by simply tagging your test executables built
with it with {!B0_meta.test} and {!B0_meta.run}.

B0 itself provides a few testing tools to make such executables. A
simplistic {!B0_testing} module is available in the [b0.std] package.
It simply runs tests as functions from [unit -> unit], provides a few
asserting tools and integrates nicely with [b0 test]'s rendering. See
an {!B0_testing.example}.

The {!B0_expect} tool for testing expectations which is expected to
change a little bit in order to integrate in [b0 test].
