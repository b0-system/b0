(*---------------------------------------------------------------------------
   Copyright (c) 2019 The b0 programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** {{:https://ocaml.org/manual/}[ocaml]} support. *)

open B0_std

(** {1:toolchain Toolchain} *)

(** OCaml toolchain tools. *)
module Tool : sig

  (** {1:comp Compilers} *)

  val comp_env_vars : B0_memo.Tool.env_vars
  (** [comp_env_vars] are environment variables that influence the
      OCaml toolchain outputs. *)

  val ocamlc : B0_memo.Tool.t
  (** [ocamlc] is the [ocamlc] tool. *)

  val ocamlopt : B0_memo.Tool.t
  (** [ocamlopt] is the [ocamlopt] tool. *)

  val ocamldep : B0_memo.Tool.t
  (** [ocamldep] is the [ocamldep] tool. *)

  val ocamlmklib : B0_memo.Tool.t
  (** [ocamlmklib] is the [ocamlmklib] tool. *)

  val ocamlobjinfo : B0_memo.Tool.t
  (** [ocamlobjinfo] is the [ocamlobjinfo] tool. *)

  (** {1:top Toplevels} *)

  val top_env_vars : B0_memo.Tool.env_vars
  (** [top_env_vars] are environment variables that influence the
      OCaml toplevel. *)

  val ocaml : B0_memo.Tool.t
  (** [ocaml] is the [ocaml] tool. *)

  val ocamlnat : B0_memo.Tool.t
  (** [ocamlnat] is the [ocamlnat] tool. *)

  (** {1:gen Lexer and Parser Generators} *)
  
  val ocamllex : B0_memo.Tool.t
  (** [ocamllex] is the [ocamllex] tool. *)
  
  val ocamlyacc : B0_memo.Tool.t
  (** [ocamlyacc] is the [ocamlyacc] tool. *)
  
  val menhir : B0_memo.Tool.t
  (** [menhir] is the [menhir] tool. *)
  
end

(** Code generated by compilers.

    In a build it is desirable to know which code is being produced
    because if both are produced the compilers may compete to
    produce some of the shared build artefacts. The following store
    keys allow to express build code {{!Code.wanted}desires} and
    determine the actual {{!Code.val-built}decision}. Note the desires
    may actually be altered by units that {e may} build FIXME maybe we
    should stick to {e must} build. *)
module Code : sig

  (** {1:code Code} *)

  type t = [ `Byte (** Bytecode. *) | `Native (** Native-code. *) ]
  (** The type for code generated by the OCaml compiler. *)

  type built = [
    | `Byte (** Bytecode. *)
    | `Native (** Native-code. *)
    | `All (** Both of them. *) ]
  (** The type indicating which code is being built. *)

  (** {1:metadata Metadata keys} *)

  val needs : built B0_meta.key
  (** [needs] indicates the unit unconditionally needs a given code
      build. *)

  val supported : built B0_meta.key
  (** [supported] indicates which backend code the unit supports.
      If the meta is unspecified defaults to [`All]. *)

  (** {1:store_keys Store keys} *)

  val wanted : [ built | `Auto ] B0_store.key
  (** [wanted] indicates which code should be built, default
      determines to [`Auto]. If [`Auto] is used and no unit that may
      build has specific {!needs} then [`Native] is used if [ocamlopt]
      can be found in the memo environment and [`Byte] otherwise. *)

  val built : built B0_store.key
  (** [build] is a memo key indicating the built code. By default
      determines by consulting [wanted_code]. *)

  (** {1:fmt Formatting} *)

  val pp : t Fmt.t
  (** [pp] formats code values. *)

  val pp_built : built Fmt.t
  (** [pp_built] formats built code values. *)
end

(** Toolchain configuration.

    This module provides access to the OCaml toolchain configuration
    as output by [ocaml{c,opt} -config]. *)
module Conf : sig

  (** {1:conf Configuration} *)

  type t
  (** The type for the OCaml toolchain configuration. *)

  val of_string : ?file:Fpath.t -> string -> (t, string) result
  (** [of_string ~file data] parses toolchain configuration from [data]
      as output by the compiler's [-config] option assuming it was read
      from file [file] (defaults to {!B0_std.Fpath.dash}). *)

  val write : B0_memo.t -> comp:B0_memo.Tool.t -> o:Fpath.t -> unit
  (** [write m ~o] writes the toolchain configuration to [o] by
      running [comp] with [-config]. *)

  val read : B0_memo.t -> Fpath.t -> t Fut.t
  (** [read m file] reads a toolchain configuration from [file]. *)

  (** {1:fields Fields} *)

  val find : string -> t -> string option
  (** [find f c] looks up the field [f] in configuration [c].
      See [ocamlc -config] for the list of fields. *)

  val version : t -> int * int * int * string option
  (** [version c] is the compiler version string
      ["major.minor[.patchlevel][+additional-info]"] parsed
      using
      [(major, minor, patch, additional-info)]. If [patch-level]
      is absent it is turned into a [0]. *)

  val where : t -> Fpath.t
  (** [where c] is the location of OCaml's library directory. *)

  val asm_ext : t -> Fpath.ext
  (** [asm_ext] is the file extension for assembly files. *)

  val dll_ext : t -> Fpath.ext
  (** [dll_ext] is the file extension for C dynamic libraries. *)

  val exe_ext : t -> Fpath.ext
  (** [ext_ext] is the file extension for executable binaries. *)

  val lib_ext : t -> Fpath.ext
  (** [ext_lib] is the file extension for C static libraries. *)

  val obj_ext : t -> Fpath.ext
  (** [obj_ext] is the file extension for C object files. *)

  val has_dynlink : t -> bool
  (** [has_dynlink] determines whether the platform supports
      dynamic linking. *)

  (** {1:convert Converting} *)

  val to_string_map : t -> string String.Map.t
  (** [to_string_map c] are the fields of [c] as a string map. *)

  val of_string_map : string String.Map.t -> (t, string) result
  (** [of_string_map m] is a configuration from string map [m].
      [m] needs at least on key for each parsed field above otherwise
      the function errors. *)

  (** {1:store_key Store key} *)

  val key : t B0_store.key
  (** [conf] is a memo key store with the OCaml configuration. *)

  val version' : B0_build.t -> (int * int * int * string option) Fut.t
  (** [version' b] gets {!Conf.version} from {!key}. *)
end

(** {1:modules Modules} *)

(** Module names *)
module Modname : sig

  (** {1:name Module names} *)

  type t = string
  (** The type for unqualified, capitalized, module names. *)

  val v : string -> t
  (** [v n] is a module name for [n], the result is capitalized. *)

  val of_path_filename : Fpath.t -> t
  (** [of_path_filename f] is the basename of [f], without extension,
      capitalized. This assumes the basename of [f] follows the OCaml file
      naming convention mandated by the toolchain. If you know that may not
      be the case use {!mangle_filename}. *)

  val equal : t -> t -> bool
  (** [equal n0 n1] is [true] iff [n0] and [n1] are the same module name. *)

  val compare : t -> t -> int
  (** [comare n0 n1] is a total order on module names compatiable with
      {!equal}. *)

  val pp : t Fmt.t
  (** [pp] formats a module name. *)

  (** Module name sets. *)
  module Set = String.Set

  (** Module name maps. *)
  module Map = String.Map

  (** {1:mangled Filename mangling} *)

  val mangle_filename : string -> t
  (** [mangle_filename s] is module name obtained by mangling
      the filename [s] as follows:

      {ol
      {- Remove any trailing [.ml] or [.mli].}
      {- Map any dash [-] (0x2D) or dot [.] (0x2E) to an underscore
         [_] (0x5F).}
      {- Map any byte not allowed in OCaml compilation unit names to its two
         digits capital hexadecimal encoding.}
      {- If the result does not start with an US-ASCII letter, prefix
         the unit name with ['M'].}
      {- Capitalize the first letter.}}

      The transformation is consistent with {!of_path_filename} on files
      that follows the OCaml toolchain convention. However the
      transformation is not injective. Here are a few examples:

{v
           filename   Module name
 ----------------------------------------
    publish-website   Publish_website
    publish_website   Publish_website
     import-data.ml   Import_data
 import-data.xml.ml   Import_data_xml
 import-data.script   Import_data_script
          mix+match   Mix2Bmatch
        _release.ml   M_release
v} *)
end


(** Module digested references.

    {b TODO.} Use that in [B0_odoc]. *)
module Modref : sig

  (** {1:modrefs Module references} *)

  type t
  (** The type for module references as found in compilation objects.
      This is a module name and a digest of its interface. *)

  val make : string -> Digest.t -> t
  (** [make n d] is a module reference with name [n] and digest [d]. *)

  val name : t -> Modname.t
  (** [name m] is the capitalized module name of module reference [m]. *)

  val digest : t -> Digest.t
  (** [digest m] is the interface digest of module reference [m]. *)

  val equal : t -> t -> bool
  (** [equal m m'] is [true] iff [m] and [m'] are the same reference. *)

  val compare : t -> t -> int
  (** [compare m m'] is a total order on module references. *)

  val pp : t Fmt.t
  (** [pp] formats a module reference. *)

  (** Module reference sets. *)
  module Set : sig
    include Set.S with type elt = t

    val pp : ?sep:unit Fmt.t -> elt Fmt.t -> t Fmt.t
    (** [pp ~sep pp_elt ppf rs] formats the elements of [rs] on [ppf].
        Each element is formatted with [pp_elt] and elements are
        separated by [~sep] (defaults to {!B0_std.Fmt.cut}). If the set is
        empty leaves [ppf] untouched. *)

    val dump : t Fmt.t
    (** [dump ppf ss] prints an unspecified representation of [ss] on
          [ppf]. *)
  end

  (** Module reference maps. *)
  module Map : sig
    include Map.S with type key = t

    val dom : 'a t -> Set.t
    (** [dom m] is the domain of [m]. *)

    val of_list : (key * 'a) list -> 'a t
    (** [of_list bs] is
        [List.fold_left (fun m (k, v) -> add k v m) empty bs]. *)

    (** {1:add Additional adds} *)

    val add_to_list : key -> 'a -> 'a list t -> 'a list t
    (** [add k v m] is [m] with [k] mapping to [l] such that [l] is
        [v :: find k m] if [k] was bound in [m] and [[v]] otherwise. *)

    val add_to_set :
      (module Stdlib.Set.S with type elt = 'a and type t = 'set) ->
      key -> 'a -> 'set t -> 'set t
    (** [add (module S) k v m] is [m] with [k] mapping to [s] such that [s] is
          [S.add v (find k m)] if [k] was bound in [m] and [S.singleton [v]]
          otherwise. *)

    (** {1:fmt Formatting} *)

    val pp : ?sep:unit Fmt.t -> (key * 'a) Fmt.t -> 'a t Fmt.t
    (** [pp ~sep pp_binding ppf m] formats the bindings of [m] on
        [ppf]. Each binding is formatted with [pp_binding] and
        bindings are separated by [sep] (defaults to
        {!Format.pp_print_cut}). If the map is empty leaves [ppf]
        untouched. *)

    val dump : 'a Fmt.t -> 'a t Fmt.t
    (** [dump pp_v ppf m] prints an unspecified representation of [m] on
          [ppf] using [pp_v] to print the map codomain elements. *)
  end
end

(** Module sources.

    A small abstraction to represent OCaml modules to compile
    and find out about source dependencies via {!Tool.ocamldep}.

    {b XXX.} This abstraction supports having [.ml] and [.mli]
    in different directories. The
    {{:https://github.com/ocaml/ocaml/issues/9717}current reality though
    prevents us from that}. *)
module Modsrc : sig

  (** {1:mods Modules} *)

  (** Source dependencies.

      As found by {!Tool.ocamldep}. *)
  module Deps : sig
    val write :
      ?src_root:Fpath.t -> B0_memo.t -> srcs:Fpath.t list -> o:Fpath.t -> unit
    (** [write m ~src_root ~srcs ~o] writes the module dependencies of each
        file in [srcs] in file [o]. If [src_root] if specified it is used
        as the [cwd] for the operation and assumed to be a prefix of every
        file in [srcs], this allows the output not to the depend on absolute
        paths.

        {b UPSTREAM FIXME.} We don't actually do what is mentioned
        about [src_root]. The problem is that the path of parse errors
        end up being wrongly reported. It would be nice to add an
        option for output prefix trimming to the tool and/or control
        on the whole toolchain for how errors are reported. This means
        that for now we cannot cache these operations across
        machines. *)

    val read :
      ?src_root:Fpath.t -> B0_memo.t -> Fpath.t ->
      Modname.Set.t Fpath.Map.t Fut.t
    (** [read ~src_root file] reads dependencies produced by {!write}
        as a map from absolute file paths to their dependencies.
        Relative file paths are made absolute relative to [src_root]
        if specified. *)
  end

  type t
  (** The type for OCaml module sources, represents a module to compile
      in a build directory. *)

  val make :
    modname:Modname.t -> opaque:bool -> mli:Fpath.t option ->
    mli_deps:Modname.Set.t -> ml:Fpath.t option -> ml_deps:Modname.Set.t ->
    build_dir:Fpath.t -> t
  (** [v ~modname ~opaque ~mli ~mli_deps ~ml ~ml_deps ~build_dir]
      is a module whose name is [modname], interface file is [mli] (if
      any), interface file module dependencies is [mli_deps],
      implementation is [ml] (if any) and implementation file module
      dependencies [ml_deps].  The module is expected to be built in
      [build_dir]. For [opaque] see {!opaque}. *)

  val modname : t -> Modname.t
  (** [modname m] is [m]'s name. *)

  val opaque : t -> bool
  (** [opaque m] indicates whether the module should be treated as
      opaque for compilation. See the [-opaque] option in the OCaml
      manual. *)

  val mli : t -> Fpath.t option
  (** [mli m] is [m]'s interface file (if any). *)

  val mli_deps : t -> Modname.Set.t
  (** [mli_deps m] are [m]'s interface file dependencies. *)

  val ml : t -> Fpath.t option
  (** [ml m] is [m]'s implementation file (if any). *)

  val ml_deps : t -> Modname.Set.t
  (** [ml_deps m] are [m]'s implementation file dependencies. *)

  (** {1:files Constructing file paths} *)

  val build_dir : t -> Fpath.t
  (** [build_dir m] is the build directory for the module. *)

  val built_file : t -> ext:string -> Fpath.t
  (** [built_file m ~ext] is a file for module [m] with extension [ext]
      in directory {!build_dir}[ m]. *)

  val cmi_file : t -> Fpath.t
  (** [cmi_file m] is [built_file m ext:".cmi"]. *)

  val cmo_file : t -> Fpath.t option
  (** [cmo_file m] is [built_file m ext:".cmo"] if {!ml} is [Some _]. *)

  val cmx_file : t -> Fpath.t option
  (** [cmx_file m] is [built_file m ext:".cmx"] if {!ml} is [Some _]. *)

  val impl_file : code:Code.t -> t -> Fpath.t option
  (** [impl_file ~code m] is {!cmx_file} or {!cmo_file}
      according to [code]. *)

  val as_intf_dep_files : ?init:Fpath.t list -> t -> Fpath.t list
  (** [as_intf_dep_files ~init m] adds to [init] (defaults to [[]])
      the files that are read by the OCaml compiler if module source
      [m] is compiled in {!build_dir} and used as an interface
      compilation dependency. *)

  val as_impl_dep_files :
    ?init:Fpath.t list -> code:Code.t -> t -> Fpath.t list
  (** [as_impl_dep_files ~init ~code m] adds to [init] (defaults to
      [[]]) the files that are read by the OCaml compiler if module
      source [m] is compiled in {!build_dir} and used an
      implementation file dependency for code [code]. *)

  (** {1:map Module name maps} *)

  val map_of_srcs :
    B0_memo.t -> build_dir:Fpath.t -> srcs:Fpath.t list ->
    src_deps:Modname.Set.t Fpath.Map.t -> t Modname.Map.t
  (** [of_srcs m ~srcs ~src_deps] determines source modules values
      to be built in [build_dir] (mapped by their names) given
      sources [srcs] and their dependencies [src_deps]
      (e.g. obtainted via {!Deps.read}. If there's more than one
      [mli] or [ml] file for a given module name a warning is
      notified on [m] and a single one is kept. *)

  val sort :
    ?stable:t list -> deps:(t -> Modname.Set.t) -> t Modname.Map.t -> t list
  (** [sort ~stable ~deps srcs] sorts [srcs] in [deps] dependency order
      respecting elements mentioned in [stable] (if any). *)

  val find : Modname.Set.t -> t Modname.Map.t -> t list * Modname.Set.t
  (** [find names srcs] is [(mods, remain)] with [mods] the names
      of [names] found in [srcs] and [remain] those that are not. *)

  (** {1:convenience Convenience} *)

  val map_of_files :
    ?only_mlis:bool -> B0_memo.t -> build_dir:Fpath.t -> src_root:Fpath.t ->
    srcs:B0_file_exts.map -> t Modname.Map.t Fut.t
  (** [map_of_files m ~only_mlis ~build_dir ~src_root ~srcs] looks for
      [.ml] (if [only_mlis] is [false], default) and [.mli] files in
      [srcs] and determines sorted module sources. [src_root]
      indicates a root for the sources in [srcs] and [build_dir] are
      used to write the {!Deps} sort. *)

  val pp : t Fmt.t
  (** [pp] formats a module source *)
end

(** {1:libraries Libraries} *)

(** Library names.

    {b FIXME.} This did not become a reality.

    Library names are dot separated segments of uncapitalized OCaml
    compilation unit names. Replacing the dots by the platform
    directory separator yields the directory of the library relative to the
    [OCAMLPATH]. Here are examples of library names and corresponding
    library directories for the following [OCAMLPATH]:
{v
OCAMLPATH=/home/bactrian/opam/lib:/usr/lib/ocaml

Library name       Library directory
----------------------------------------------------------------
ptime.clock.jsoo   /home/bactrian/opam/lib/ptime/clock/jsoo
re.emacs           /home/bactrian/opam/lib/re/emacs
ocamlgraph         /usr/lib/ocaml/ocamlgraph
ocaml.unix         /usr/lib/ocaml/ocaml/unix
N/A (shadowed)     /usr/lib/ocaml/re/emacs
v}

    For legacy reasons library names also correspond to [ocamlfind]
    package names. *)
module Libname : sig

  (** {1:name Library names} *)

  type t
  (** The type for library names looked up in [OCAMLPATH].
      For legacy reasons this may also correspond to an [ocamlfind]
      package name. *)

  val v : string -> t
  (** [v s] is a library for [n]. Raises [Invalid_argument] if [s] is
      not a valid library name. *)

  val root : t -> string
  (** [root n] is the root name of [n], that is the leftmost one. *)

  val basename : t -> string
  (** [basename n] is the basename of [n], that is the right most one. *)

  val undot : rep:Char.t -> t -> string
  (** [undot ~rep n] is [n] with [.] replaced by [rep]. *)

  val to_archive_name : t -> string
  (** [to_archive_name n] is [undot ~rep:'_' n]. *)

  val of_string : string -> (t, string) result
  (** [of_string s] is a library name from [n]. *)

  val to_string : t -> string
  (** [to_string n] is [n] as a string. *)

  val to_fpath : t -> Fpath.t
  (** [to_fpath n] is [n] with dots replaced by
        {!B0_std.Fpath.dir_sep_char}. *)

  val equal : t -> t -> bool
  (** [equal n0 n1] is [true] iff [n0] and [n1] are the same library name. *)

  val compare : t -> t -> int
  (** [compare n0 n1] is a total order on library names compatible with
      {!equal}. *)

  val pp : t Fmt.t
  (** [pp] formats a library name. *)

  (** Library name sets. *)
  module Set : Set.S with type elt = t

  (** Library name maps. *)
  module Map : Map.S with type key = t
end

val libname : string -> Libname.t
(** [libname n] is [n] as an OCaml {{!Libname}library name}. This is
    a shortcut for {!Libname.v} and should be used in [B0.ml] files *)

(** Library information.

    An OCaml library is a directory with interfaces and object
    files. OCaml libraries are resolved by {{!Libname}name} using a
    {!Libresolver}. *)
module Lib : sig

  (** {1:libs Libraries} *)

  type t
  (** The type for libraries. *)

  val make :
    libname:Libname.t -> requires:Libname.t list ->
    represents:Libname.t list -> dir:Fpath.t ->
    cmis:Fpath.t list -> cmxs:Fpath.t list -> cma:Fpath.t option ->
    cmxa:Fpath.t option -> c_archive:Fpath.t option ->
    c_stubs:Fpath.t list -> js_stubs:Fpath.t list -> warning:string option -> t
  (** [make] is a library with given properties. See corresponding
      accessors for semantics. *)

  val of_dir :
    B0_memo.t -> clib_ext:Fpath.ext -> libname:Libname.t ->
    requires:Libname.t list -> represents:Libname.t list -> dir:Fpath.t ->
    archive:string option -> js_stubs:Fpath.t list -> warning:string option ->
    (t, string) result
  (** [of_dir] is a library with given properties, looked up in [dir]
      using [clib_ext] for the platform specific extension for C
      libraries.  The basename without extension of the library's
      archives is [archive] and the JavaScript stubs are
      [js_stubs]. This looks up all library files in [dir] and makes
      them ready in [m] along with [js_stubs].

      {b Note.} If [dir] doesn't follow the one library per directory
      convention this over-approximate [cmis], [cmxs] and [c_stubs]
      files. *)

  val of_unit : B0_build.t -> Conf.t -> B0_unit.t -> t option Fut.t
  (** [lib_of_unit b ocaml_conf u] defines a library from unit [u] by
      consulting {!requires}, {!respresents}, {!library}, {!modsrcs}
      and {!B0_meta.warning}.  As a side effect this
      {!B0_build.require}s [u]. *)

  (** {1:props Properties} *)

  val libname : t -> Libname.t
  (** [libname l] is the library name of [l]. *)

  val requires : t -> Libname.t list
  (** [requires l] are the libraries that are required by [l]. *)

  val represents : t -> Libname.t list
  (** [represents l] are the libraries that are represented by [l]. *)

  val dir : t -> Fpath.t
  (** [dir l] is the library directory of [l]. *)

  val cmis : t -> Fpath.t list
  (** [cmis l] is the list of cmis of [l]. *)

  val cmxs : t -> Fpath.t list
  (** [cmxs l] is the list of cmxs of [l]. *)

  val cma : t -> Fpath.t option
  (** [cma l] is the cma file of [l] (if any). *)

  val cmxa : t -> Fpath.t option
  (** [cmxa l] is the cmxa file of [l] (if any). *)

  val c_archive : t -> Fpath.t option
  (** [c_archive l] is the [cmxa]'s companion C archive of [l]. Must
      exist if the [cmxa] exists and, since 4.12 if [cmxa] is not
      empty. *)

  val c_stubs : t -> Fpath.t list
  (** [c_stubs l] is the C stubs archives of [l] (if any). *)

  val js_stubs : t -> Fpath.t list
  (** [js_stubs l] is the list of JavaScript stubs of [l] (if any). *)

  val warning : t -> string option
  (** [warning l] is the usage warning of [l] (if any). *)
end

(** Library resolvers. *)
module Libresolver : sig

  (** {1:resolvers Resolvers} *)

  (** Resolution scopes.

      Resolution scopes allow to compose and order multiple library
      resolution mechanisms. In particular it allows [b0] to lookup
      for libraries in builds before trying to resolve them in in the
      build environment. *)
  module Scope : sig

    (** {1:scopes Scopes} *)

    type find = Conf.t -> B0_memo.t -> Libname.t -> Lib.t option Fut.t
    (** The type for the scope finding function. *)

    type suggest = Conf.t -> B0_memo.t -> Libname.t -> string list option Fut.t
    (** The type for the scope missing library suggestion function. *)

    type t
    (** The type for scopes. A scope has a name, a library lookup
        function and possibly a function to indicate how to
        troubleshoot a missing library. *)

    val make : name:string -> find:find -> suggest:suggest -> t
    (** [make ~name ~find ~suggest] is a scope named [name] looking
        up libraries with [find] and giving suggestions on missing
        libraries with [suggest]. *)

    (** {1:props Properties} *)

    val find : t -> find
    (** [find scope] is the lookup function of [scope]. *)

    val name : t -> string
    (** [name scope] is the name of [scope]. *)

    val suggest : t -> suggest
    (** [suggest scope] is the suggestion function of [scope] *)

    (** {1:predefined Predefined} *)

    val cache_dir_name : string
    (** [cache_dir_name] is a name that can be used for the
         cache directory of resolution scopes. *)

    val ocamlpath : cache_dir:Fpath.t -> t
    (** [ocampath ~cache_dir] looks up libraries according to the
        OCaml library convention in the [OCAMLPATH] of the memo using
        [cache_dir] to cache results.

        {b Note.} This is a nop for now. *)

    val ocamlfind : cache_dir:Fpath.t -> t
    (** [ocamlfind ~cache_dir] looks up libraries using [ocamlfind]
        and caches the result in [cache_dir].

        A few simplyifing assumptions are made by the resolver, which
        basically boil down to query the library name [LIB] with:
 {[
   ocamlfind query LIB -predicates byte,native -format …
 ]}
        to derive a {!Lib.t} value (see the sources for the current
        -format arugment. This may fail on certain libraries. In
        particular it assumes a one-to-one map between [ocamlfind]
        package names and library names and that the archives are in
        the library directory.

        Also the [ocaml.threads], [threads] and [threads.posix]
        libraries are treated specially: they all lookup
        [threads.posix] with predicates [mt,mt_posix] on OCaml < 5.0.0
        and simply [threads] otherwise. [threads.vm] is unsupported
        (but deprecated anyways). *)

    val build : B0_build.t -> Conf.t -> t
    (** [build b conf] is a library resolver scope for OCaml
        libraries that can be built in [b]. For a unit [u] to be
        recognized as such it has to:
        {ul
        {- It looks if the library name is {{!library}defined}
           by a unit that {{!B0_build.may_build}may} be built. If that
           is the case it creates a library out of that build unit via
           {!Lib.of_unit} and resolves to library name to it.}
        {- TODO public stuff}} *)
  end

  type t
  (** The type for library resolvers. *)

  val make : B0_memo.t -> Conf.t -> Scope.t list -> t
  (** [make m ocaml_conf scopes] is a library resolver looking for
      libraries in the given [scopes], in order. [ocaml_conf] is the
      toolchain configuration. [m] gets marked by [ocamlib]. *)

  (** {1:store_key Store key} *)

  val default : B0_store.t -> B0_memo.t -> t Fut.t
  (** [default store memo] determines a default library resolver for
      {!key}.  It uses the {!Conf.key} in [store] and uses a
      {!Scope.build} with the build found in the store via
      {!B0_build.self} followed by an {!Scope.ocamlfind} in memo and a
      cache in the {{!B0_build.shared_build_dir}directory} of the
      build. *)

  val key : t B0_store.key
  (** [key] is the library resolver used by the build units defined by
      {!B0_ocaml}. It defaults to {!default}. *)

  (** {1:properties Properties} *)

  val lookups : t -> Lib.t option Fut.t Libname.Map.t
  (** [lookups r] are the lookups performed in [r] so far. *)

  val memo : t -> B0_memo.t
  (** [memo r] is the memoizer of [r]. *)

  val ocaml_conf : t -> Conf.t
  (** [ocaml_conf r] is the OCaml configuration of [r]. *)

  val scopes : t -> Scope.t list
  (** [scopes r] are the scopes of [r]. *)

  (** {1:lookup Lookup} *)

  val find : B0_memo.t -> t -> Libname.t -> Lib.t option Fut.t
  (** [find m r libname] finds library [libname] in [r].
      [m] is used to report notifications. *)

  val get : B0_memo.t -> t -> Libname.t -> Lib.t Fut.t
  (** [get m r libname] gets library [libname] in [r]. The memo of [r]
      fails if the library cannot be found. [m] is used to report
      notication or failure. *)

  val get_list_and_reprs :  B0_memo.t -> t -> Libname.t list -> Lib.t list Fut.t
  (** [get_list r libnames] looks up libraries [libnames] in [r] and
      the libraries they {!B0_ocaml.represents}. Libraries are returned in
      the given order and the memo of [r] fails if a library cannot be found. *)

  val get_list_and_deps : B0_memo.t -> t -> Libname.t list -> Lib.t list Fut.t
  (** [get_list_and_deps b libnames] looks up the libraires [libnames]
      and their dependencies in [r]. The result is a sorted in
      (stable) dependency order and the memo of [r] fails if a library
      cannot be found. *)
end

(** {1:units Build units} *)

(** {2:exec Executables} *)

val exe :
  ?wrap:(B0_unit.build_proc -> B0_unit.build_proc) -> ?doc:string ->
  ?meta:B0_meta.t -> ?c_requires:Cmd.t -> ?requires:Libname.t list ->
  ?public:bool -> ?name:string -> string -> srcs:B0_srcs.sels -> B0_unit.t
(** [exe tool_name] is a build unit for an executable tool named [tool_name]
    (without the platform specific extension).
    {ul
    {- [public] indicates whether the bare [name] is made available
       unscoped outside the unit definition scope (defaults to [false]).}
    {- [doc] is the unit doc string.}
    {- [meta] is the initial metadata.}
    {- [c_requires] FIXME hack, something more sensitive should be done.
       This each of these options are passed as [-cclib] options.}
    {- [requires] are the OCaml libraries required to compile the executable.}
    {- [name] is the name of the unit (defaults to [n]).}
    {- [srcs] are the executable sources. All files with extension [.ml],
       [.mli], [.c] and [.h] are considered for compiling and linking the
       executable.}
    {- [wrap] allows to extend the build procedure you must call the given
       build procedure. TODO maybe remove once we have good {!frag}.}} *)

val script :
  ?wrap:(B0_unit.build_proc -> B0_unit.build_proc) -> ?doc:string ->
  ?meta:B0_meta.t -> ?public:bool -> ?name:string -> Fpath.t -> B0_unit.t
(** [script file] is a build unit for an OCaml script in [file].  The
    build unit simply checks that it typechecks and is runnable. Due to
    upstream limitations this is a hack. You should invoke your main as:
    {[
let () = if !Sys.interactive then () else main ()
    ]}
    {ul
    {- [public] indicates whether the basename of [file] is made available
       unscoped outside the unit definition scope (defaults to [false]).}
    {- [doc] is the unit doc string}
    {- [meta] is the initial metadata}
    {- [wrap] allows to extend the build procedure. You must call the
       given build procedure.}}

    FIXME [file] should become a src so that it can be generated. *)

(** {2:libs Libraries} *)

val lib :
  ?wrap:(B0_unit.build_proc -> B0_unit.build_proc) -> ?doc:string ->
  ?meta:B0_meta.t -> ?c_requires:Cmd.t -> ?requires:Libname.t list ->
  ?represents:Libname.t list -> ?public:bool -> ?name:string -> Libname.t ->
  srcs:B0_srcs.sels -> B0_unit.t
(** [lib n ~srcs] is a built unit for a library named [n] made of
    sources [srcs].
    {ul
    {- [public] indicates whether the library name [n] is made
       available unscoped outside the scope of the unit definition
       (defaults to [true])}
    {- [doc] is the unit doc string.}
    {- [meta] is the initial metadata.}
    {- [c_requires] FIXME hack, something more sensitive should be done.
       This each of these options are passed as [-cclib] options.}
    {- [requires] are the OCaml libraries required to compile the library.}
    {- [represents] are the OCaml libraries represented by this library.}
    {- [name] is the name of the build unit (default to [n] with [.]
        substituted by [-])}
    {- [srcs] are the library sources. extension [.ml],
       [.mli], [.c] and [.h] are considered for compiling and linking the
       executable.}
    {- [wrap] allows to extend the build procedure you must call the given
       build procedure. TODO maybe remove once we have good {!frag}.}} *)

val deprecated_lib :
  ?wrap:(B0_unit.build_proc -> B0_unit.build_proc) -> ?doc:string ->
  ?meta:B0_meta.t -> ?represents:Libname.t list -> ?warning:string ->
  ?public:bool -> ?name:string -> Libname.t -> B0_unit.t
(** [deprecated_lib n] is an empty build unit for a deprecated library
    named [n]. Most arguments are like in {!lib}.
    {ul
    {- [rerpesents] is used {!represents}}
    {- [warning] is used for {!B0_meta.warning}, if unspecified
       a warning message is derived from [represents].}
    {- The unit is tagged with {!B0_meta.deprecated}}} *)

(** {2:metadata Metadata}

    This is mostly needed if you need to process units or define
    your own. OCaml {{!units}units} set these key appropriately. *)

val tag : bool B0_meta.key
(** [tag] indicates the entity is related to OCaml. For example this can be
    used to select OCaml build units. *)

val c_requires : Cmd.t B0_meta.key
(** [c_requires] hack for now this simply passes these options as
    [-cclib] options. *)

val library : Libname.t B0_meta.key
(** [library] on a unit specifies that the unit defines the library with
    the given name. *)

val modsrcs : Modsrc.t Modname.Map.t Fut.t B0_meta.key
(** FIXME quick hack this should not be in meta, or not. *)

val requires : Libname.t list B0_meta.key
(** [requires] on a unit specifies the OCaml libraries needed to
    compile a unit. *)

val represents : Libname.t list B0_meta.key
(** [represents] on a library build unit specifies that the library
    represents these libraries. *)

(** {1:source Source Transformations} *)

val ocamllex : B0_srcs.sels -> B0_srcs.sel
(** [ocamllex srcs] runs [ocamllex] on each [mll] file in [srcs] *)

val ocamlyacc : B0_srcs.sels -> B0_srcs.sel
(** [ocamlyacc srcs] runs [ocamlyacc] on each [mly] file in [srcs] *)

val menhir : B0_srcs.sels -> B0_srcs.sel
(** [menhir srcs] runs [menhir] on each [mly] file in [srcs] *)

(** {1:frag Build fragments}

    See {{!page-TODO.b0_ocaml}TODO}. *)

(** {2:toolchain_ops Toolchain operations} *)

(** Compiling. *)
module Compile : sig

  (** {1:basic Basic} *)

  val c_to_o :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> comp:B0_memo.Tool.t -> opts:Cmd.t -> reads:Fpath.t list ->
    c:Fpath.t -> o:Fpath.t -> unit
  (** [c_to_o m ~comp ~opts ~reads ~c ~o] compiles the C file [c] to
      the object file [o] with options [opts] and using compiler
      [comp].  It assumes the compilation depends on C include header
      files [reads] whose parent directories are added as [-I]
      options. *)

  val mli_to_cmi :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    and_cmti:bool -> B0_memo.t -> comp:B0_memo.Tool.t -> opts:Cmd.t ->
    reads:Fpath.t list -> mli:Fpath.t -> o:Fpath.t -> unit
  (** [mli_to_cmi ~and_cmti m ~comp ~opts ~reads ~mli ~o] compiles the
      file [mli] to the cmi file [o] and, if [and_cmti] is [true], to
      the cmti file [Fpath.(o -+ ".cmti")] with options [opts] and
      using compiler [comp]. It assumes the compilation depends on cmi
      files [reads] whose parent directories are added as [-I]
      options. *)

  val ml_to_cmo :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    and_cmt:bool -> B0_memo.t -> opts:Cmd.t -> reads:Fpath.t list ->
    has_cmi:bool -> ml:Fpath.t -> o:Fpath.t -> unit
  (** [ml_to_cmo ~and_cmt m ~opts ~reads ~has_cmi ~ml ~o] compiles the
      file [ml] to cmo file [o] and, if [and_cmt] is [true], to the
      cmt file [Fpath.(o -+ ".cmt")] with options [opts]. It assumes
      the compilation depends on the cmi files [reads] whose parent
      directories are added as [-I] options. [has_cmi] indicates
      whether the [ml] file already a corresponding cmi file, in which
      case it should be in [reads] (FIXME specify path directly ?). *)

  val ml_to_cmx :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    and_cmt:bool -> B0_memo.t -> opts:Cmd.t -> reads:Fpath.t list ->
    has_cmi:bool -> ml:Fpath.t -> o:Fpath.t -> unit
  (** [ml_to_cmx ~and_cmt m ~opts ~reads ~has_cmi ~ml ~o ~and_cmt]
      compiles the file [ml] to cmx file [o] and, if [and_cmt] is
      [true], to the cmt file [Fpath.(o -+ ".cmt")] with options
      [opts]. It assumes the compilation depends on the cmi and cmx
      files [reads] whose parent directories are added as [-I]
      options. [has_cmi] indicates whether the [ml] file already has a
      corresponding cmi file, in which case it should be in [reads]
      (FIXME specify path directly ?). *)

  val ml_to_impl :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> code:Code.t -> opts:Cmd.t -> reads:Fpath.t list ->
    has_cmi:bool -> ml:Fpath.t -> o:Fpath.t -> and_cmt:bool -> unit
  (** [ml_to_impl] is {!ml_to_cmo} or {!ml_to_cmx} according to [code].
       Beware that the given arguments must be common to both *)

  (** {1:srcs [Modsrc] convenience}

      A few helpers that deal directly with the {!Modsrc} abstraction. *)

  val modsrc_intf :
    and_cmti:bool -> B0_memo.t -> comp:B0_memo.Tool.t -> opts:Cmd.t ->
    requires:Lib.t list -> modsrcs:Modsrc.t Modname.Map.t -> Modsrc.t ->
    unit
  (** [modsrc_intf m ~opts ~requires ~modsrcs ~and_cmti src]
      compiles the interface of [src] with options [opts] and compiler
      [comp] assuming its dependencies are in [modsrcs] and
      [requires]. If [and_cmti] is [true] the [cmti] file is also
      produced. If [src] has no [.mli] this is a nop. *)

  val modsrc_impl :
    and_cmt:bool -> B0_memo.t -> code:Code.t -> opts:Cmd.t ->
    requires:Lib.t list -> modsrcs:Modsrc.t Modname.Map.t -> Modsrc.t ->
    unit
  (** [modsrc_impl m ~code ~opts ~requires ~modsrcs src] compile the
      implementation of [src] with option [opts] to code [code]
      asuming it dependencies are in [modsrc]. If [and_cmt] is [true]
      the [cmt] file is also produced. If [src] has no [.ml] this is
      a nop. *)

  val intfs :
    and_cmti:bool -> B0_memo.t -> comp:B0_memo.Tool.t -> opts:Cmd.t ->
    requires:Lib.t list -> modsrcs:Modsrc.t Modname.Map.t -> unit
  (** [intfs] iters {!modsrc_intf} over the elements of [modsrcs]. *)

  val impls :
    and_cmt:bool -> B0_memo.t -> code:Code.t -> opts:Cmd.t ->
    requires:Lib.t list -> modsrcs:Modsrc.t Modname.Map.t -> unit
   (** [impls] iters {!modsrc_impl} over the elements of [modsrcs]. *)
end

(** Archiving. *)
module Archive : sig

  val cstubs :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> conf:Conf.t -> opts:Cmd.t -> c_objs:Fpath.t list ->
    odir:Fpath.t -> oname:string -> unit
  (** [cstubs m ~conf ~opts ~c_objs ~odir ~oname] creates in directory
      [odir] C stubs archives for a library named [oname]. *)

  (* FIXME change the odir/oname into files as usual and pass the
     c stubs archive directly. *)

  val byte :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> conf:Conf.t -> opts:Cmd.t -> has_cstubs:bool ->
    cobjs:Fpath.t list -> odir:Fpath.t -> oname:string -> unit
  (** [byte_archive m ~opts ~has_cstubs ~cobjs ~obase] creates in directory
      [odir] a bytecode archive named [oname] with the OCaml bytecode
      compilation objects [cobjs]. *)

  val native :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> conf:Conf.t -> opts:Cmd.t -> has_cstubs:bool ->
    cobjs:Fpath.t list -> odir:Fpath.t -> oname:string -> unit
  (** [native m ~opts ~has_cstubs ~cobjs ~obase] creates in directory
      [odir] a native code archive named [oname] with the OCaml native
      code compilation objects [cobjs]. *)

  val code :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> conf:Conf.t -> opts:Cmd.t -> code:Code.t -> has_cstubs:bool ->
    cobjs:Fpath.t list -> odir:Fpath.t -> oname:string -> unit
  (** [archive] is {!byte} or {!native} according to [code]. *)

  val native_dynlink :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> conf:Conf.t -> opts:Cmd.t -> has_cstubs:bool -> cmxa:Fpath.t ->
    o:Fpath.t -> unit
end

(** Linking. *)
module Link : sig
  val byte :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> conf:Conf.t -> opts:Cmd.t -> c_objs:Fpath.t list ->
    cobjs:Fpath.t list -> o:Fpath.t -> unit
  (** [byte_exe m ~opts ~c_objs ~cmos ~o] links the C objects [c_objs]
      and the OCaml compilation object files [cobjs] into a byte code
      executable [o] compiled in [-custom] mode. *)

  val native :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> conf:Conf.t -> opts:Cmd.t -> c_objs:Fpath.t list ->
    cobjs:Fpath.t list -> o:Fpath.t -> unit
  (** [byte_exe m ~opts ~c_objs ~cobjs ~o] links the C objects
      [c_objs] and the OCaml compilation object files [cobjs] into a
      native code executable [o], in [cobjs] you need to add the C [lib_ext]
      file of `cmxa` files if they exist (since 4.12 they may not exist).
      An include is added to each element of [cobjs] in order to
      lookup potential C stubs. *)

  val code :
    ?post_exec:(B0_zero.Op.t -> unit) -> ?k:(B0_zero.Op.t -> int -> unit) ->
    B0_memo.t -> conf:Conf.t -> opts:Cmd.t -> code:Code.t ->
    c_objs:Fpath.t list -> cobjs:Fpath.t list -> o:Fpath.t -> unit
  (** [code] is {!byte} or {!native} according to [code]. *)
end

(** {2:cobjs Compiled object information} *)

(** Compiled object information. *)
module Cobj : sig

  val archive_ext_of_code : Code.t -> Fpath.ext
  (** [archive_ext_of_code code] is [.cma] or [.cmxa] according to [code]. *)

  val object_ext_of_code : Code.t -> Fpath.ext
  (** [object_ext_of_code code] is [.cmo] or [.cmx] according to [code]. *)

  (** {1:cobjs Compilation objects} *)

  type t
  (** The type for compilation objects. This can represent one
      of a [cmi], [cmti], [cmo], [cmx], [cmt], [cma] or [cmxa] file. *)

  val file : t -> Fpath.t
  (** [file c] is the file path of [c]. *)

  val defs : t -> Modref.Set.t
  (** [defs c] are the modules defined by [c]. If there's more than
      one you are looking an archive. *)

  val deps : t -> Modref.Set.t
  (** [deps c] is the set of modules needed by [defs c]. More precisely
      these are the module interfaces imported by [c]. See also {!link_deps}. *)

  val link_deps : t -> Modref.Set.t
  (** [link_deps c] is the set of modules needed to link [defs c].

      {b Note.} Unclear whether this is the right data. Basically
      these are the module references that of {!deps} whose name is in the
      {{:https://github.com/ocaml/ocaml/blob/a0fa9aa6e85ca4db9fc19389f89be9ff0d3bd00f/file_formats/cmo_format.mli#L36}required globals}
      (bytecode) or {{:https://github.com/ocaml/ocaml/blob/trunk/file_formats/cmx_format.mli#L43}imported implementations} (native code) as reported
      by ocamlobjinfo. Initially we'd use [deps] for link dependencies
      but it turns out that this may break on
      {{:https://github.com/ocaml/ocaml/issues/8728}certain} install
      structures. It's unclear whether we need both {!deps} and
      {!link_deps} and/or if that's the correct information. *)

  val pp : t Fmt.t
  (** [pp] formats an compilation object. *)

  val sort : ?deps:(t -> Modref.Set.t) -> t list -> t list * Modref.Set.t
  (** [sort ~deps cobjs] is [cobjs] stable sorted in dependency
      order according to [deps] (defaults to {!link_deps}), tupled with
      external dependencies needed by [cobjs]. *)

  val equal : t -> t -> bool
  (** [equal c0 c1] is [Fpath.equal (file c0) (file c1)]. *)

  val compare : t -> t -> int
  (** [compare] is a total order on compilation objects compatible
      with {!equal}. *)

  (** Compilation objects sets. *)
  module Set : Set.S with type elt = t

  (** Compilation objectx maps. *)
  module Map : Map.S with type key = t

  (** {1:io IO} *)

  val write : B0_memo.t -> cobjs:Fpath.t list -> o:Fpath.t -> unit
  (** [write m ~cobjs o] writes information about the compilation [cobjs]
      to [o]. *)

  val read : B0_memo.t -> Fpath.t -> t list Fut.t
  (** [read m file] has the [cobjs] of a {!write} to [file]. *)

  val of_string : ?file:Fpath.t -> string -> (t list, string) result
  (** [of_string ~file data] parses compilation object information from
      [data] as output by {!Tool.ocamlobjinfo} assuming it was
      read from [file] (defaults to {!B0_std.Fpath.dash}). *)
end

(** {2:crunch Crunching} *)

(** Crunching data into OCaml values. *)
module Crunch : sig
  val id_of_filename : string -> string
  (** [id_of_filename] is {!Modname.mangle_filename} uncapitalized.*)

  val string_to_string : id:string -> data:string -> string
  (** [string_to_string ~id ~data] let binds binary [data] to [id] using
      a string. *)
end

(** {1:action Actions} *)

val action : B0_action.t
(** [action] is the [.ocaml] action.

    See [b0 -- .ocaml --help] for more information. *)

val action_ocaml : B0_action.t
(** [action_ocaml] is the [.ocaml.ocaml] action. This action forces
    a byte code build and loads the resulting build in the [ocaml]
    toplevel.

    See [b0 -- .ocaml.ocaml --help] for more information. *)
