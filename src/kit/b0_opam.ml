(*---------------------------------------------------------------------------
   Copyright (c) 2020 The b0 programmers. All rights reserved.
   Distributed under the ISC license, see terms at the end of the file.
  ---------------------------------------------------------------------------*)

open B00_std
open B00_std.Result.Syntax

let () = B0_def.Scope.lib "opam"

module File = struct

  (* Generic representation *)

  type value =
    [ `Raw of string | `B of bool | `S of string | `L of bool * value list ]

  type field = string * value
  type section = string * string option * t
  and comment = string
  and item = [ `Comment of comment | `Field of field | `Section of section ]
  and t = item list

  let gen_by ~gen = `Comment ("Generated by " ^ gen)
  let gen_by_b0 = gen_by ~gen:"b0 %%VERSION%%"
  let v2 = `Field ("opam-version", `S "2.0")

  (* Formatting *)

  let escape =
    let char_len = function '"' -> 2 | _ -> 1 in
    let set_char b i = function
    | '"' -> Bytes.set b i '\\'; Bytes.set b (i+1) '"'; 2
    | c -> Bytes.set b i c; i + 1
    in
    String.byte_escaper char_len set_char

  let pp ppf file =
    let rec pp_value ppf = function
    | `Raw r -> Fmt.string ppf r
    | `B b -> Fmt.bool ppf b
    | `S s -> Fmt.pf ppf "\"%s\"" (escape s)
    | `L (vert, vs) ->
        let box = if vert then Fmt.vbox else Fmt.hovbox in
        let pp_list ppf vs = Fmt.pf ppf "[%a]" Fmt.(list ~sep:sp pp_value) vs in
        (box ~indent:1 pp_list) ppf vs
    in
    let pp_field ppf (f, v) = Fmt.pf ppf "%s: @[%a@]" f pp_value v in
    let pp_comment = Fmt.(hbox @@ any "# " ++ string) in
    let rec pp_item ppf = function
    | `Comment c -> pp_comment ppf c
    | `Field f -> pp_field ppf f
    | `Section (n, opt, file) ->
        let pp_opt = Fmt.(option (any " " ++ parens string)) in
        Fmt.pf ppf "@[<v2>%s%a{@,%a}@]" n pp_opt opt pp_file file
    and pp_file ppf file = (Fmt.vbox (Fmt.list pp_item)) ppf file in
    pp_file ppf file

  let to_string file =
    let b = Buffer.create (10 * 1024) in
    pp (Format.formatter_of_buffer b) file; Buffer.contents b

  (* Package file generation *)

  let opam_file_addendum =
    let doc = "opam file fragment added at the end" in
    B0_meta.Key.v "opam-file-addendum" ~doc ~pp_value:pp

  let build_field =
    let doc = "opam file build: field" in
    B0_meta.Key.v "opam-build" ~doc ~pp_value:Fmt.string

  let install_field =
    let doc = "opam file install: field" in
    B0_meta.Key.v "opam-install" ~doc ~pp_value:Fmt.string

  let of_meta m =
    let string field k m acc = match B0_meta.find k m with
    | None -> acc | Some s -> `Field (field, `S s) :: acc
    in
    let string_raw field k m acc = match B0_meta.find k m with
    | None -> acc | Some s -> `Field (field, `Raw s) :: acc
    in
    let string_list ~vert field k m acc = match B0_meta.find k m with
    | None -> acc
    | Some ms -> `Field (field, `L (vert, List.map (fun s -> `S s) ms)) :: acc
    in
    let fields =
      [ string_list ~vert:true "maintainer" B0_meta.maintainers;
        string_list ~vert:true "authors" B0_meta.authors;
        string "homepage" B0_meta.homepage;
        string "doc" B0_meta.online_doc;
        string "dev-repo" B0_meta.repo;
        string "bug-reports" B0_meta.issues;
        string_list ~vert:false "tags" B0_meta.description_tags;
        string_list ~vert:false "license" B0_meta.licenses;
        string_raw "build" build_field;
        string_raw "install" install_field;
        string "synopsis" B0_meta.synopsis;
        string "description" B0_meta.description; ]
    in
    let add_field m acc f = f m acc in
    let (fs : item list) = List.fold_left (add_field m) [] fields in
    let add = Option.value ~default:[] (B0_meta.find opam_file_addendum m) in
    List.rev_append fs add

  (* Opam file generation *)

  let synopsis_of_title t = (* Get $DESCR in "$NAME $SEP $DESCR" *)
    let ws = Char.Ascii.is_white and tok c = not @@ Char.Ascii.is_white c in
    let skip = String.lose_left in
    let d = t |> skip ws |> skip tok |> skip ws |> skip tok |> skip ws in
    if d <> "" then Some d else None

  let synopsis_and_description_of_cmark file =
    let contents = Os.File.read file |> Log.if_error ~use:"" in
    let convert (t, d) = synopsis_of_title t, d in
    Option.map convert (B00_cmark.first_section ~preamble:true contents)

  let of_pack p =
    (* For now this uses only meta so could be melded into of_meta.
       In the future we might derive things like deps from units though. *)
    let m = B0_pack.meta p in
    let m = match B0_meta.(mem synopsis m, mem description m) with
    | true, true -> m
    | has_syn, has_descr ->
        let readme = (* FIXME scope/root/meta *) Fpath.v "README.md" in
        let extracted = match Fpath.get_ext readme with
        | ".md" -> synopsis_and_description_of_cmark readme
        | _ -> None
        in
        match extracted with
        | None -> m
        | Some (syn, d) ->
            let syn = Option.value ~default:"" syn in
            let m = if has_syn then m else B0_meta.(add synopsis syn m) in
            let m = if has_descr then m else B0_meta.(add description d m) in
            m
    in
    let m =
      if B0_meta.mem build_field m then m else
      let build = Fmt.str {|[[ "b0" "--lock" "-p" "%s" ]]|} (B0_pack.name p) in
      B0_meta.add build_field build m
    in
    gen_by_b0 :: v2 :: of_meta m
end

(* Metadata *)

let tag = B0_meta.Key.tag "opam" ~doc:"opam related entity"

module Meta = struct
  let opam_file_addendum = File.opam_file_addendum
  let build = File.build_field
  let install = File.install_field
  let package =
    let pp_value = Fmt.string in
    B0_meta.Key.v "opam-package" ~doc:"Defined opam package name" ~pp_value
end

(* Cmdlets *)

let file ps =
  Log.if_error ~use:B00_cli.Exit.no_such_name @@
  let* ps = match ps with
  | [] -> Ok (List.sort B0_pack.compare (B0_pack.list ()))
  | ps -> B0_pack.get_list ps
  in
  match List.filter (B0_pack.has_meta tag) ps with
  | [] -> Ok B00_cli.Exit.ok
  | ps ->
      let files = List.map File.of_pack ps in
      let sep = Fmt.(cut ++ cut) in
      Log.app (fun m -> m "@[<v>%a@]" Fmt.(list ~sep File.pp) files);
      Ok B00_cli.Exit.ok

let file_cmd cmdlet ~argv =
  let open Cmdliner in
  let packs =
    let doc =
      "Use pack $(docv). If unspecified all of them with a $(b,B0_opam.tag)"
    in
    B0_cli.Arg.packs ~doc ()
  in
  let term = Term.(const file $ packs) in
  B0_cmdlet.Cli.run cmdlet ~argv term

let file_cmdlet =
  let doc = "Generate opam files from build packs" in
  B0_cmdlet.v "file" ~doc (`Cmd file_cmd)

module Cmdlet = struct
  let file = file_cmdlet
end

(*---------------------------------------------------------------------------
   Copyright (c) 2020 The b0 programmers

   Permission to use, copy, modify, and/or distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  ---------------------------------------------------------------------------*)
